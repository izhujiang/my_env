" profile vim's startup
" vim --startuptime /tmp/log

" Run :options, pop up the option window
"      -- get a list of options with a one-line explanation and grouped by subjuect.
"      -- navigate around and change the value of an option under the cursor.

" minimum config for vim
set nocompatible

" command				                detection	plugin		indent
" filetype plugin indent on	    on		    on		    on
filetype plugin indent on       " enable file type detection,
syntax on                       " syntax highlighting

let g:vim_home = expand('$HOME/.vim')
let g:vim_data = expand('$HOME/.local/share/vim')
let g:netrw_liststyle = 3
let g:EditorConfig_exclude_patterns = ['fugitive://.*', 'scp://.*']

" set verbose = 16      " For debugging script.

" The Vim distribution comes with a few packages ($VIMRUNTIME/pack/dist/opt/) that you can optionally use.
"
" Extended matching with '%', makes the '%' command jump to matching HTML tags, if/else/endif in Vim scripts, etc.
" %	Cycle forward through matching groups, such as 'if', 'else', 'endif', as specified by |b:match_words|.
" g%	Cycle backwards through matching groups
" [%	Go to [count] previous unmatched group
" ]%	Go to [count] next unmatched group
" a%	In Visual mode, select the matching group,
packadd! matchit

packadd! editorconfig

" The comment package, allows to toggle comments for a single line, a range of lines or a selected text object.
" gc{motion}	to toggle comments for the selected motion
" {Visual}gc	to comment/uncomment the highlighted lines.
packadd! comment

"packadd! nohlsearch

" *****************************************************************************
if v:version >= 900
  let	g:mapleader = ','
  let	g:maplocalleader = ' '
  " or
  " let	g:maplocalleader = "\<Space>"
else
  let mapleader = ','
  let maplocalleader = ' '
endif
" mapping the reverse character search command to another key.
noremap <Bslash> ,

" set autochdir                   " change working directories on selecting new files
set autoread                      " reload file when modified outside of vim
set autowrite                     " Write the contents of the file, if it has been modified on (1) buffer switch commands(:next), (2) 'jump' between buffers command(tag, mark, jump list), (3) ':make', (4) vim-go makes use of this option as well.
set nobackup
set noswapfile

" set background=dark
set backspace=eol,start,indent
set clipboard^=unnamed            " enable system commands(⌘-c/x/v) dealing with 'unnamed' register
if has('unnamedplus')
  set clipboard^=unnamedplus
endif
set cmdheight=2
set complete+=i
set completeopt=menuone      " DON'T show up extra information in popup window, a bit distracting
" set completeopt=longest,menu,preview  " DON'T use longest, which only insert the longest common text of the matches.

" set conceallevel=2
set confirm
set cursorline                    " highlight current line
set dictionary+=/usr/share/dict/words

set encoding=utf-8                " the character encoding used inside Vim (buffers, registers, expressions, viminfo, etc.)
" set fileencodings=utf-8,gbk     " charset in .editorconfig
" set fileformats=unix,mac,dos    " end_of_line in .editorconfig

set fillchars=vert:\|,fold:-,foldopen:,foldclose:,diff:-,eob:~

set foldmethod=syntax
set foldlevel=10
set foldnestmax=10

set formatoptions=jtcrqlnwmp    " How automatic formatting is done,  default: tcqj,
                                  " o -- Automatically insert the current comment leader after hitting 'o' or 'O' in Normal mode.
                                  " a -- Automatic formatting of paragraphs.

" The built-in :grep command runs synchronously,
"    - grep uses POSIX regular expressions
"    - ack uses Perl regular expressions
"    - ripgrep uses rust regex crate, Fast non-backtracking, Perl-compatible
if executable('rg')
" TODO: create custom :Rg commands rather than override :grep command. like :Ggrep in fugitive.vim
  set grepprg=rg\ --column\ --line-number\ --no-heading\ --smart-case
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

" set helplang=cn             " help file in chinese
set hidden
set history=2000              " recall commands from history in Command-line (Ex) mode
set hlsearch
set incsearch
set ignorecase
set smartcase
set infercase
set iskeyword+=-              " treat dash-separated words as a word text object
set autoindent
set smartindent

set laststatus=2
set noshowmode                " 'mode' in laststatus is unnecessary anymore since statusline plug provides 'mode'

" set lazyredraw              "only be set temporarily when performing an operation where redrawing may cause flickering or cause a slowdown.

" set list                          " show tab and space with different chars. toggle it using :set invlist
set listchars=tab:>~,space:_
set mouse=""
set nrformats=octal,hex,alpha,bin   " enable Ctrl-A/Ctrl-X to work on octal and hex numbers, as well as characters
set number
set relativenumber
set numberwidth=4
set path+=**                        " set sub-directories will search for gf, :find command
set ruler
set scrolloff=8
" set sessionoptions=blank,buffers,curdir,folds,help,options,winsize,tabpages,slash,unix
set shiftround
" set showcmd
" set showmode
set shortmess=aT
set showmatch
set showtabline=0             " Never show tabpages, use tmux instead tabpages
if !exists('$SHELL')
    set shell=/bin/sh
endif

set sidescrolloff=8
" set signcolumn=yes
set smarttab
" set spell
" set spelllang=fr    "default en
set spelloptions+=camel
" setlocal spellfile+=~/.dict/spellfile/fr.utf-8.add
"
" set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)\
set switchbuf=uselast,useopen      " DON'T use newtab: fugitive.vim's :Gclog and Ggrep will open new buffers in the new tabs when switchbuf include newtab.
" set termguicolors
set tildeop                        " tilde command '~' behaves like an operator.
set timeoutlen=700
set ttimeoutlen=100       " timeoutlen or ttimeoutlen contributes to a delay after pressing <Esc>.
set title
set titlestring=%F

" set undofile
set undolevels=2000
" idle time to trigger, the swap file will be written to disk, set noswapfile to disable swap file.
" also used for the |CursorHold| autocommand event.
set updatetime=2000
" set virtualedit=block
" set viminfo='20,\"50,:20,/20,%,n~/.viminfo      " When Vim is started and the 'viminfo' option is non-empty,

set wildmenu
" set wildchar=<Tab>
" set wildcharm=<C-z>
set wildmode=list:longest,list:full
set wildignorecase
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__,*.sqlite,*.db
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
if has('win16') || has('win32')
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store
else
    set wildignore+=.git\*,.hg\*,.svn\*
endif
set winminwidth=5
" Don't Wrap lines (it is stupid, except raw document or markdown.)
set nowrap
"set whichwrap+=[,],<,>,h,l

"------------------------------------------------------------------------------
" key mapping (map commands)and abbreviations
"------------------------------------------------------------------------------
" temporarily enable for debugging vim config file
" noremap <silent> <leader>sv :source $MYVIMRC<CR>

" Disable arrowskeys and force to forget the mapping (trick)
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>

" -- Navigation -----------------------------------
" buffer list
nnoremap ]a :next<CR>
nnoremap [a :previous<CR>
nnoremap ]A :last<CR>
nnoremap [A :first<CR>
" argument list
nnoremap ]b :bnext<CR>
nnoremap [b :bprevious<CR>
nnoremap ]B :blast<CR>
nnoremap [B :bfirst<CR>
" quickfix list
nnoremap ]q :cnext<CR>
nnoremap [q :cprevious<CR>
nnoremap ]Q :clast<CR>
nnoremap [Q :cfirst<CR>
" location list
nnoremap ]l :lnext<CR>
nnoremap [l :lprevious<CR>
nnoremap ]L :llast<CR>
nnoremap [L :lfirst<CR>
" tag matchlist
nnoremap ]t :tnext<CR>
nnoremap [t :tprevious<CR>
nnoremap ]T :tlast<CR>
nnoremap [T :tfirst<CR>


" diff/change
" ]c
" [c
"
" change list
" g;  -- Go to [count] older position in change list.
" g,  -- Go to [count] newer position in change list.
"
" spell
" ]s [s ]S [S

" use built-in gt/gT for :tabnext/tabprev or Ex-commands directly
" OR use (better) tmux to arrange workspaces.
" nnoremap gt :tabnext<CR>
" nnoremap gT :tabprev<CR>

" -- buffers and augument list -----------------------------------
cnoremap <leader>% :lcd %:p:h<CR>
nnoremap <leader>e :e <C-R>=expand('%:p:h') . '/' <CR>
nnoremap <leader>n :enew \| startinsert <CR>
nnoremap <silent> <leader>w :w<CR>
nnoremap <silent> <leader>W :noautocmd w<CR>
nnoremap <silent> <Leader>c :bdelete<CR>
nnoremap <silent> <Leader>C :bwipeout<CR>
" Alternate file
" <C-^>/<C-6>, or :buf #<CR>

" -- windows(ventana) and tab pages -----------------------------------
" window commands prefixing with CTRL-W is quite good.
" nmap <silent> <leader>v <C-w>

nnoremap <leader><Bar> :vsplit<CR>
nnoremap <leader>- :split<CR>

"navigate  windows
" Use builtin <C-w>hjkl keybinds to jump between windows
nnoremap <silent> <A-h> :wincmd h<CR>
nnoremap <silent> <A-j> :wincmd j<CR>
nnoremap <silent> <A-k> :wincmd k<CR>
nnoremap <silent> <A-l> :wincmd l<CR>
nnoremap <silent> <A-w> :wincmd p<CR>

inoremap <silent> <A-h> <C-\><C-N><C-w>h
inoremap <silent> <A-j> <C-\><C-N><C-w>j
inoremap <silent> <A-k> <C-\><C-N><C-w>k
inoremap <silent> <A-l> <C-\><C-N><C-w>l
inoremap <silent> <A-w> <C-\><C-N><C-w>p

tnoremap <silent> <A-h> <C-\><C-N><C-w>h
tnoremap <silent> <A-j> <C-\><C-N><C-w>j
tnoremap <silent> <A-k> <C-\><C-N><C-w>k
tnoremap <silent> <A-l> <C-\><C-N><C-w>l
tnoremap <silent> <A-w> <C-\><C-N><C-w>p

" Should disable ^<-, ^->, ^↑, ^↓ in MissionControl shortcuts (macos)
nnoremap <silent> <A-Up> :resize +2<CR>
nnoremap <silent> <A-Down> :resize -2<CR>
nnoremap <silent> <A-Left> :vertical resize -5<CR>
nnoremap <silent> <A-Right> :vertical resize +5<CR>

inoremap <silent> <A-Up> <Esc>:resize +2<CR>gi
inoremap <silent> <A-Down> <Esc>:resize -2<CR>gi
inoremap <silent> <A-Left> <Esc>:vertical resize -5<CR>gi
inoremap <silent> <A-Right> <Esc>:vertical resize +5<CR>gi

tnoremap <silent> <A-Up> <C-\><C-n>:resize +2<CR>a
tnoremap <silent> <A-Down> <C-\><C-n>:resize -2<CR>a
tnoremap <silent> <A-Left> <C-\><C-n>:vertical resize -5<CR>a
tnoremap <silent> <A-Right> <C-\><C-n>:vertical resize +5<CR>a


" tag list
" generate tags file (index of source code)
command! -nargs=0 CTagsGen execute 'silent !ctags -R --exclude=.git --fields=+l' | execute 'redraw!'

" diff
" do (diff obtain) for :diffget (modify the current buffer to undo difference with another buffer)
" dp (diff put) for :diffput (modify another buffer to undo difference with the current buffer)

" clean highlight, <C-l>, On macOS, used as default shortcut for sending a newline in many applications.
nnoremap <silent> <C-l> :nohlsearch<CR>
nnoremap <silent> <leader>gu :nohlsearch<CR>:diffupdate<CR>

"better move lines up/down
nnoremap <A-m> :m .+1<CR>
nnoremap <A-S-m> :m .-2<CR>
inoremap <A-S-m> <Esc>:m .-2<CR>gi
inoremap <A-m> <Esc>:m .+1<CR>gi
vnoremap <A-m> :m '>+1<CR>gv=gv
vnoremap <A-S-m> :m '<-2<CR>gv=gv

" CAUTION
"	Single quotes (') are for literal strings (no special key interpretation).
"	Double quotes (") allow escape sequences (like \<C-w>) to represent special key combinations or control characters.

" better indenting, DON'T overwrite default > and < in visual mode
" vnoremap < <gv
" vnoremap > >gv

" better paste
" paste over visual selection
vnoremap <silent> p P
" With P, the unnamed register not changed, v_P is repeatable.(ref :h v_p and v_P)
" nnoremap <leader>p "+gP

" Next/Previous Search Result (with centering the result)
nnoremap <expr> n 'Nn'[v:searchforward] . 'zv'
xnoremap <expr> n 'Nn'[v:searchforward]
onoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward] . 'zv'
xnoremap <expr> N 'nN'[v:searchforward]
onoremap <expr> N 'nN'[v:searchforward]

" search for the current selection In Visual and Select mode using * and #
" same as * and # for searching the word under current cursor In normal mode.
xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

" Execute last substitute
" &	  Synonym for `:s` (repeat last substitute).  Note that the flags are not remembered, thus it might actually work differently.  use `:&&` to keep the flags.
" g&  Synonym for `:%s//~/&` (repeat last substitute with last search pattern on all lines with the same flags).
"
" The & command is a synonym for :s, which repeats the last substitution without remembering flags.
" Making & trigger the :&& command is more useful.  It preserves flags and therefore produces more consistent results.
nnoremap & :&&<CR>
xnoremap & :'<,'>&&<CR><esc>

" -- quickfix and location list -----------------------------------
nnoremap <silent> <A-q> :call <SID>Toggle_qf_loc_list('quickfix', 0)<CR>
nnoremap <silent> <A-Q> :call <SID>Toggle_qf_loc_list('location', 0)<CR>

" Qargs populates the argument list with each files name in the quickfix list (generated by :vimgrep or :make)
command! -nargs=0 -bar Qargs execute 'args ' QuickfixFilenames()

" ------------------------------------------------------------------------------
" built-in terminal emulation
if v:version >= 800
  nnoremap <silent> <A-1> :horizontal terminal<CR>
  nnoremap <silent> <A-2> :vertical terminal<CR>
endif

" TODO: keymap in terminal-mode
" " To map <Esc> to exit terminal-mode:
" tnoremap <Esc> <C-\><C-n>
" " <C-v><Esc> (Verbatim escape) send an Escape key to the program running inside the terminal buffer.
" tnoremap <C-v><Esc> <Esc>
" " To simulate |i_CTRL-R| in terminal-mode:
" tnoremap <expr> <C-R> '<C-\><C-N>"'.nr2char(getchar()).'pi'

" Toggle options ------------------------------------------------------------------------------
" Toggle background between dark and light
nnoremap <silent> <leader>ob :call ToggleBackground()<CR>
function! ToggleBackground() abort
  if &background == "dark"
    set background=light
  else
    set background=dark
  endif
endfunction

" Toggle conceallevel between 0 and 3
nnoremap <silent> <leader>oc :call ToggleConcealLevel()<CR>
function! ToggleConcealLevel() abort
  if &conceallevel == 0
    set conceallevel=3
  else
    set conceallevel=0
  endif
endfunction

nnoremap <silent> <leader>on :setlocal number! <Bar> :setlocal relativenumber!<CR>
nnoremap <leader>op :setlocal paste!<CR>
nnoremap <silent> <leader>os :setlocal spell!<CR>
nnoremap <silent> <leader>ow :setlocal wrap!<CR>

" Command-line and Command Window
cnoremap <C-o> <C-f>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
" type %% on the command-line prompt, expands to the directory of the active buffer, like :e %%, :r %%, :we %%.
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:p:h').'/' : '%%'

cnoreabbrev <expr> grep  (getcmdtype() ==# ':' && getcmdline() =~# '^grep')  ? 'silent grep': 'grep'
cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() =~# '^lgrep') ? 'silent lgrep' : 'lgrep'
" ZZ(:x), built-in Command, svae current buffer and quit the current window, and quit in case is the last edit-window.
" same as ZZ except refuseing to abandonthe current buffer which has been edited.
cnoreabbrev Q! q!
cnoreabbrev Qall! qall!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq

" misc ------------------------------------------------------------------------------
" Abbreviations are used in Insert mode, Replace mode and Command-line mode.
" -- save typing for often used long words.
" -- automatically correct obvious spelling errors.
iabbrev adn and
iabbrev waht what
iabbrev @@    m.zhujiang@gmail.com
iabbrev cc Copyright 2024 Jiang Zhu, all rights reserved.

"------------------------------------------------------------------------------
augroup event_buffer
  autocmd!

  autocmd FileType gitcommit,gitrebase,gitconfig set bufhidden=delete
  autocmd FileType txt,markdown,gitcommit setlocal spell wrap linebreak

  if executable('lldb')
    autocmd FileType c,c++ call s:Config_termdebug(['lldb', '--'])
  else
    autocmd FileType c,c++ call s:Config_termdebug('gdb')
  endif
  if executable('rust-lldb')
    autocmd FileType rust call s:Config_termdebug('rust-lldb')
  endif

  " go to last loc when opening a buffer
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | execute "normal! g`\"" | endif
  autocmd BufReadPost * call s:Close_with_q()

  autocmd BufWritePre * call s:Auto_create_dir(expand("<afile>"))
augroup END

augroup event_window
  autocmd!
  " Resize splits automatically when Vim window is resized
  autocmd VimResized * tabdo wincmd =

  if v:version >= 800
      " autocmd TerminalOpen * if &buftype == 'terminal' | :startinsert | endif
      autocmd BufWinEnter,WinEnter * if &buftype == 'terminal' | silent! normal i | endif
      " autocmd BufLeave * if &buftype == 'terminal' | silent! stopinsert | endif
      if v:versionlong >= 8023591
        autocmd WinClosed * if &buftype == 'terminal' | bdelete! | endif
      endif
  endif
augroup END

" *****************************************************************************
" Helper Functions
function! s:Close_with_q() abort
  " Skip normal buffers
  if &buftype ==# ''
    return
  endif

  setlocal nobuflisted
  setlocal bufhidden=wipe
  nnoremap <silent> <buffer> q :call <SID>smart_close()<CR>
endfunction

function! s:smart_close() abort
  let l:winid = win_getid()
  let l:wininfo = getwininfo(l:winid)[0]
  let l:ft = &filetype

  " Handle quickfix and loclist windows
  if get(l:wininfo, 'quickfix', 0)
    " Check if it's a location list (not quickfix)
    if get(l:wininfo, 'loclist', 0)
      lclose
      return
    else
      cclose
      return
    endif
  endif

  " Handle known special filetypes
  if l:ft ==# 'help' || l:ft ==# 'man' || l:ft ==# 'lspinfo'
    quit
  " elseif l:ft =~# '^fzf' || l:ft ==# 'TelescopePrompt'
    " close
  else " default close
    close
  endif
endfunction

" Quickfix
function! s:Toggle_qf_loc_list(list_type, forced)
  if a:list_type ==# 'quickfix'
    if getqflist({'winid': 1}).winid != 0
      cclose
    else
      copen
    endif
  else
    if getloclist(0, {'winid': 1}).winid != 0
      lclose
    elseif !empty(getloclist(0))
      lopen
    endif
  endif
endfunction

function! s:VSetSearch(cmdtype)
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

function! QuickfixFilenames()
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

" Define the function that handles directory creation
function! s:Auto_create_dir(file)
  " auto_create_dir
  " Skip URLs (e.g. network paths like 'http://', 'ftp://', etc.)
  if a:file =~ '^\\w\\w\\+://'
    return
  endif

  " Get the real file path or use the match if the path is invalid
  let l:file_path = fnamemodify(a:file, ':p:h')
  " Create the directory path if it doesn't exist
  call mkdir(l:file_path, 'p')
endfunction


" Termdebug is Vim's built-in terminal debugger interface that debug programs (primarily C/C++) directly within Vim using GDB compatible Debugger.
" cmd: debugger, string or string list [cmd, arguments]
" c/c++, lldb, gdb
" rust, rust-lldb, rust-gdb
function! s:Config_termdebug(debugger)
  if !exists('g:termdebug_config')
    " \ 'substitute_path' -- map remote to local files for remote debugging. more info :h termdebug-remote-window
    "
    " \ 'variables_window': v:true,
    " \ 'variables_window_height': 10,
    " \ 'disasm_window': v:true,
    " \ 'disasm_window_height': 15,
    "
    let g:termdebug_config = {
    \ 'wide': 163,
    \ 'sign': '>>',
    \ 'sign_decimal': v:true,
    \ 'winbar': v:false,
    \ 'evaluate_in_popup': v:true,
    \ 'debug': v:false,
    \ 'close_on_exit': v:true,
    \ 'map_K': v:false,
    \ 'map_minus': v:false,
    \ 'map_plus': v:false,
    \ }

    " GDB command prompt that appears in the terminal window
    " 'use_prompt': v:true    -- true on macOS, change the layout windows (left:gdb, middle:program, right:source), otherwise crash (no idea yet)
    " 'use_prompt': v:false   -- false on linux, the layout of windows (left-top: gdb, left-bottom: program, right: source) is perfect.
    if !(a:debugger is 'gdb')
      let g:termdebug_config['use_prompt'] = v:true
      let  g:termdebug_config['command'] = a:debugger
    endif
    packadd termdebug

  " Common Cmds in gdb window:
  " - CTRL-C	interrupt the program
  " - next		execute the current line and stop at the next line
  " - step		execute the current line and stop at the next statement,
      " entering functions
  " - until		execute until past the current cursor line or past a specified
      " position or the current stack frame returns
  " - finish	execute until leaving the current function
  " - where		show the stack
  " - frame N	go to the Nth stack frame
  " - continue	continue execution

    nnoremap <silent> <leader>tb :Termdebug<CR>

    " usefull Commands, Jump to target window
    " :Gdb
    " :Program
    " :Source
    " :Var
    " :Asm

    " Hook into Termdebug lifecycle events
    augroup TermdebugKeymaps
      autocmd!
      autocmd User TermdebugStartPost call timer_start(50, { -> s:TermdebugKeymaps(v:true) })
      autocmd User TermdebugStopPost  call s:TermdebugKeymaps(v:false)
    augroup END
  endif
endfunction

" Storage riginal mappings
let s:saved_maps = {}

function! s:SaveMapping(lhs) abort
  if !has_key(s:saved_maps, a:lhs)
    let info = maparg(a:lhs, 'n', 0, 1)
    if !empty(info)
      let s:saved_maps[a:lhs] = info
    endif
  endif
endfunction

function! s:RestoreMapping(lhs) abort
  if has_key(s:saved_maps, a:lhs)
    let info = s:saved_maps[a:lhs]
    if !empty(info)
      execute printf('%snoremap %s %s %s',
            \ info.mode,
            \ info.silent ? '<silent>' : '',
            \ a:lhs,
            \ info.rhs)
    endif
    call remove(s:saved_maps, a:lhs)
  else
    silent! nunmap <buffer> a:lhs
  endif
endfunction

" --- print selection or symbol under cursor ---
 function! s:TermdebugPrint() abort
   if mode() ==# 'v' || mode() ==# 'V'
     " Visual mode: evaluate selected text
     normal! "vy
     let expr = getreg('v')
     execute 'Evaluate ' . expr
   else
     " Normal mode: evaluate symbol under cursor
     let word = expand('<cword>')
     if !empty(word)
       execute 'Evaluate ' . expand('<word>')
     else
       echomsg 'No symbol under cursor'
     endif
   endif
 endfunction

 " --- Toggle debug keymaps ---
 function! s:TermdebugKeymaps(enable) abort
   if a:enable
     " Save existing mappings before overriding
     for key in ['<leader>tc', '<leader>tn', '<leader>ti', '<leader>tq', 'K', '-', '+']
       call s:SaveMapping(key)
     endfor

     " Define temporary Termdebug mappings using native commands
     nnoremap <silent> <leader>tc :Continue<CR>
     nnoremap <silent> <leader>tn :Over<CR>
     nnoremap <silent> <leader>ti :Step<CR>
     nnoremap <silent> <leader>tq :Stop<CR>
     nnoremap <silent> - :Down<CR>
     nnoremap <silent> + :Up<CR>

     " Smart print (Evaluate)
     nnoremap <silent> K :call <SID>TermdebugPrint()<CR>
     xnoremap <silent> K :<C-u>call <SID>TermdebugPrint()<CR>

   else
     " Restore previously saved mappings
     for key in keys(s:saved_maps)
       call s:RestoreMapping(key)
     endfor
   endif
 endfunction

" **** main entry *****************************************************************************
" Include complementary plugins and user's local vim config
let plugins_path = g:vim_home . '/plugins.vim'

if filereadable(plugins_path)
  execute 'source ' . plugins_path
endif

let extra_path = g:vim_home . '/extra.vim'
if filereadable(extra_path)
  execute 'source ' . extra_path
endif

" silent! colorscheme habamax